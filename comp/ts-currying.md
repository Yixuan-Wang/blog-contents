---
title: "Tymnastics (2): æŸ¯é‡ŒåŒ–"
date: 2023-02-21
category: comp
series: [tymnastics, 2]
tags:
  - pl
  - typescript
keywords:
  - type
  - fp
---

ç”¨ TypeScript çš„ç±»å‹ç³»ç»Ÿæè¿°ä¸€ä¸ªå‡½æ•°çš„æŸ¯é‡ŒåŒ–è¿‡ç¨‹ã€‚

<!-- more -->

## æŸ¯é‡ŒåŒ–

æŸ¯é‡ŒåŒ–ï¼ˆ[currying](https://en.wikipedia.org/wiki/Currying)ï¼‰æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­å¸¸è§çš„ä¸€ç§æŠ€æœ¯ã€‚å®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š

1. ä¸€ä¸ªåªæ¥æ”¶ä¸€ä¸ªå‚æ•°æˆ–è€…æ²¡æœ‰å‚æ•°çš„å‡½æ•° $f$, å®ƒçš„æŸ¯é‡ŒåŒ–å¾—åˆ°å®ƒè‡ªèº«;
2. ä¸€ä¸ªå‡½æ•° $f(x_1, x_2, \dots, x_n)$ï¼Œå®ƒçš„æŸ¯é‡ŒåŒ–å¾—åˆ°æ¥æ”¶ $x_1$ ä½œä¸ºå‚æ•°, è¿”å›ä¸€ä¸ªæ¥æ”¶ $x_2, \dots, x_n$ ä½œä¸ºå‚æ•°ä¸”è¿”å› $f(x_1, x_2, \dots, x_n)$ çš„å‡½æ•°çš„æŸ¯é‡ŒåŒ–ç»“æœ.

çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```typescript
let add         = (a: number, b: number, c: number) => a + b + c;
let curried_add = (a: number) => (b: number) => (c: number) => a + b + c;

console.log(add(1, 2, 3)); // 6
console.log(curried_add(1)(2)(3)); // 6

// ç­‰ä»·äº:
let add_1 = curried_add(1);
let add_1_2 = add_1(2);
let result = add_1_2(3);
```

è€ƒè™‘åˆ° Haskell çš„ç±»å‹æ³¨è§£ï¼Œå¯ä»¥æ˜ç™½æŸ¯é‡ŒåŒ–åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„é‡è¦æ€§ã€‚é¡ºä¾¿ï¼ŒæŸ¯é‡ŒåŒ–ï¼ˆ*curry*-ingï¼‰å¾—åè‡ªé€»è¾‘å­¦å®¶ Haskell *Curry*ğŸ˜ã€‚

```haskell
add :: Integer -> Integer -> Integer -> Integer
-- æœ‰ä¸‰ä¸ª Integer å‚æ•°ä¸”è¿”å›ä¸€ä¸ª Integer çš„å‡½æ•°
```

## æŸ¯é‡ŒåŒ– I

åœ¨ TypeScript ä¸­ï¼Œå¦‚ä½•ç»™æŸ¯é‡ŒåŒ–ä½œç±»å‹æ³¨è§£å‘¢ï¼Ÿå‚çœ‹ [Type Challenges](https://github.com/type-challenges/type-challenges) çš„[ç¬¬ 17 é¢˜](https://github.com/type-challenges/type-challenges/blob/main/questions/00017-hard-currying-1/README.md)ã€‚


### è§£æ³• 1

æ ¹æ®ä»¥ä¸Šçš„é€’å½’å®šä¹‰ï¼Œæ‰€æœ‰çš„å•å‚æ•°çš„å‡½æ•°çš„æŸ¯é‡ŒåŒ–æ˜¯å…¶æœ¬èº«ã€‚æˆ‘ä»¬å¯ä»¥ä»¥è¿™ä¸ªæ¡ä»¶ä½œä¸ºé€’å½’çš„ç»ˆæ­¢æ¡ä»¶ã€‚äºæ˜¯æœ‰ï¼š

```typescript
type IsCurried<F> = F extends (..._: any[]) => any
  ? F extends (_: any) => any
    ? true
    : false
  : true;

type Curry<T> = IsCurried<T> extends true
  ? T
  : T extends (p0: infer P0, ...ps: infer Ps) => infer R
  ? (p0: P0) => Curry<(...ps: Ps) => R>
  : never;

declare function currying<F>(fn: F): Curry<F>;
```

é¦–å…ˆï¼Œæˆ‘ä»¬å†™å‡ºä¸€ä¸ªç±»å‹ `IsCurried<F>`ã€‚å®ƒé¦–å…ˆæ£€æŸ¥ `F` æ˜¯å¦æ˜¯å‡½æ•°ã€‚è‹¥æ˜¯å‡½æ•°ï¼Œåˆ™è¿”å›å®ƒæ˜¯å¦æ˜¯å•å‚æ•°çš„ã€‚ä¸€ä¸ªå¤šå‚æ•°çš„å‡½æ•°ä¸€å®šä¸æ˜¯æŸ¯é‡ŒåŒ–è¿‡çš„ã€‚ç‰¹åˆ«åœ°ï¼Œä¸€ä¸ªæ— å‚æ•°çš„å‡½æ•°çš„ç±»å‹ç­‰ä»·äº `(_: unknown) => ...`ã€‚

å…¶æ¬¡æ˜¯ä¸»è¦è¿ç®—çš„é€’å½’ç±»å‹ `Curry<T>`ã€‚å¦‚æœ `T` å·²ç»æŸ¯é‡ŒåŒ–è¿‡äº†ï¼Œåˆ™ç›´æ¥è¿”å›ï¼Œå¦åˆ™ `T` æ˜¯ä¸€ä¸ªå¤šå‚æ•°çš„å‡½æ•°ï¼Œé€šè¿‡ `infer` å…³é”®å­—å¯¹å®ƒçš„ç±»å‹è¿›è¡ŒåŒ¹é…ï¼Œå¾—åˆ°ç¬¬ä¸€ä¸ªå‚æ•° `P0` ã€æ‰“åŒ…çš„å‰©ä½™å‚æ•° `Ps` å’Œè¿”å›å€¼ `R` çš„ç±»å‹ï¼Œå¾—åˆ°çš„æŸ¯é‡ŒåŒ–çš„ç»“æœåº”è¯¥æ˜¯ `(_: P0) => Curry<(..._: Ps) => R>`ã€‚


### è§£æ³• 2

å¦å¤–ä¸€ä¸ªæ€è·¯æ˜¯å¯¹å‚æ•°åšæ–‡ç« ã€‚è§‚å¯Ÿ Haskell çš„å‡½æ•°ç±»å‹è®°æ³•ï¼Œåªéœ€è¦æŠŠ `(T, U, V) -> R` è¿™æ ·çš„å‡½æ•°è½¬åŒ–æˆ `T -> U -> V -> R` å³å¯ã€‚ç”±æ­¤æœ‰ï¼š


```typescript
type CurriedFunc<P extends any[], R> = P extends []
  ? () => R
  : P extends [infer P0, ...infer Ps]
  ? Ps extends []
    ? (_: P0) => R
    : (_: P0) => CurriedFunc<Ps, R>
  : never;

type Curry<F> = F extends (..._: any[]) => any
  ? CurriedFunc<Parameters<F>, ReturnType<F>>
  : never;

declare function currying<F>(fn: F): Curry<F>;
```

è¿™ä¸ªæ€è·¯æ˜¯åœ¨å‚æ•°åˆ—è¡¨ä¸Šè¿›è¡ŒåŒ¹é…ï¼Œè€Œéå‡½æ•°æœ¬èº«ï¼Œæœ€ç»ˆä»å‚æ•°åˆ—è¡¨è‡ªå†…å‘å¤–æ„å»ºç±»å‹ã€‚

## æŸ¯é‡ŒåŒ– I çš„å®ç°

```typescript
function currying<F extends (..._: any[]) => any>(fn: F) {
  if (fn.length <= 1) return fn;
  else {
    return (p0: Parameters<F>[0]) => currying(fn.bind(null, p0));
  }
}
```

å®ç°çš„æ€è·¯åŸºæœ¬ä¸Šå°±æ˜¯åˆ©ç”¨ `Function.prototype.bind` æ–¹æ³•ä¾æ¬¡ä»å·¦å‘å³ç»‘å®šå‚æ•°ã€‚


## æŸ¯é‡ŒåŒ– II

Type Challenges [ç¬¬ 462 é¢˜](https://github.com/type-challenges/type-challenges/blob/main/questions/00462-extreme-currying-2/README.md) æå‡ºäº†ä¸€ç§æ–°çš„*åŠ¨æ€*æŸ¯é‡ŒåŒ–ï¼Œæ¯æ¬¡ä¸ä»…èƒ½ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œè¿˜å¯ä»¥ä¼ å…¥å¤šä¸ªï¼Œç›´åˆ°åœ¨æŸä¸€æ¬¡è°ƒç”¨ä¸­ï¼Œç´¯è®¡ä¼ å…¥äº†å’ŒåŸå‡½æ•°ç›¸åŒä¸ªæ•°çš„å‚æ•°ï¼Œå¾—åˆ°è¿”å›å€¼ã€‚

~~æ€ä¹ˆä¼šæœ‰è¿™ä¹ˆè¯¡å¼‚çš„éœ€æ±‚å•Š~~ğŸ™ƒï¼Ÿ

```typescript
type CurriedFunc<
  Leftover extends any[],
  Ret,
  Pre extends any[] = []
> = Leftover extends []  // (1)
  ? (..._: Pre) => Ret // (1)
  : Leftover extends [infer L0, ...infer Ls] // (2)
  ? Ls extends [] // (3)
    ? (..._: [...Pre, L0]) => Ret // (3)
    : ((..._: [...Pre, L0]) => CurriedFunc<Ls, Ret, []>) // (4)
      & CurriedFunc<Ls, Ret, [...Pre, L0]> // (5)
  //  ^ (6)
  : never;

type DynamiclyCurry<F> = F extends (..._: any[]) => any
  ? CurriedFunc<Parameters<F>, ReturnType<F>>
  : never;

declare function dynamicCurrying<F>(fn: F): DynamiclyCurry<F>;
                              // ^ åœ¨è¿™é‡ŒåŠ ä¸Š (..._: any[]) => any çš„çº¦æŸ
                              //   æ‰èƒ½é€šè¿‡ Type Challenges çš„æµ‹è¯•
                              //   ä½†å­—é¢é‡ç±»å‹ `true` ä¼šè¢«è¿˜åŸæˆç±»å‹ `boolean`
```

å»¶ç»­ä¹‹å‰çš„æ€è·¯ 2ã€‚å¯¹äºä¸€ä¸ªå½¢å¦‚ `T, U, V, ...` çš„å‚æ•°åˆ—è¡¨ï¼Œåœ¨ä»»æ„ä¸¤ä¸ªç±»å‹ä¹‹é—´ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©æˆªæ–­å¹¶æ’å…¥ä¸€ä¸ª `->` æˆ–ä¸æˆªæ–­ã€‚æ¯”å¦‚ï¼Œå¯¹äº `(T, U, V) -> R` è€Œè¨€ï¼Œä»¥ä¸‹éƒ½æ˜¯åˆæ³•çš„åŠ¨æ€æŸ¯é‡ŒåŒ–ç»“æœï¼š
```
(T  ,   U  ,   V) ->  R
(T  ,   U) ->  V  ->  R
 T  -> (U  ,   V) ->  R
 T  ->  U  ->  V  ->  R 
```

æ‰€ä»¥ï¼ŒæŠŠåŸå‡½æ•°å‚æ•°åˆ—è¡¨æƒ³è±¡æˆä¸€ä¸ªé˜Ÿé¦–åœ¨å·¦ç«¯çš„é˜Ÿåˆ—ï¼Œæ¯ä¸€ä¸ªä»é˜Ÿé¦–å¼¹å‡ºçš„å‚æ•° `T`ï¼Œæœ‰ä¸¤ç§é€‰æ‹©ï¼šå‹å…¥ä¹‹å‰çš„å‚æ•°åˆ—è¡¨åï¼ˆ`(..., T`ï¼‰ï¼Œæˆ–è€…æˆªæ–­å¹¶è¿›å…¥ä¸‹ä¸€å±‚å‡½æ•°ï¼ˆ`(..., T) -> (`ï¼‰ï¼Œæˆ–è€…ä¸æˆªæ–­å¹¶ç•™å¾…ç»§ç»­å»¶ä¼¸ï¼ˆ`(..., T,`ï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æ³›å‹ç±»å‹è®¾ç½®ä¸‰ä¸ªç±»å‹å‚æ•°ï¼Œ`Leftover` è¡¨ç¤ºåŸå‡½æ•°å‚æ•°æ„æˆçš„é˜Ÿåˆ—ä¸­å‰©ä½™çš„å‚æ•°ï¼Œ`Pre` è¡¨ç¤ºå½“å‰æ­£åœ¨æ„å»ºçš„å‚æ•°åˆ—è¡¨, `Ret` è¡¨ç¤ºæœ€ç»ˆçš„è¿”å›å€¼ã€‚

æ‰€ä»¥ï¼Œé¦–å…ˆæˆ‘ä»¬åˆ¤æ–­ `Leftover` æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºåˆ™ç›´æ¥ç”¨ `Pre` å’Œ `Ret` æ„å»ºæœ€å†…å±‚çš„å‡½æ•°<sup>(1)</sup>ã€‚ä¸‹ä¸€æ­¥ï¼Œè§£åŒ…åŒ¹é… `Leftover`<sup>(2)</sup>ï¼Œè‹¥åªå‰©æœ€åä¸€é¡¹ `L0`ï¼Œåˆ™å°† `L0` é™„åœ¨ `Pre` åå’Œ `Ret` æ„å»ºæœ€å†…å±‚çš„å‡½æ•°<sup>(3)</sup>ã€‚

è¿›å…¥æ­£é¢˜ã€‚å¦‚æœé€‰æ‹©æˆªæ–­ï¼Œåˆ™æŠŠ `L0` é™„åœ¨ `Pre` åæ„å»ºå‡½æ•°å‚æ•°ï¼ˆ`[...Pre, L0]`ï¼‰ï¼Œè¿”å›å€¼ä¸‹ä¸€å±‚å‡½æ•°ï¼ˆ`Pre=[]`ï¼‰â€”â€”ä¹Ÿå°±æ˜¯åœ¨å…¶ä½™å‚æ•°ï¼ˆ`Ls`ï¼‰ä¸Šçš„åŠ¨æ€æŸ¯é‡ŒåŒ– `CurriedFunc<Ls, Ret, []>`<sup>(4)</sup>ã€‚å¦‚æœé€‰æ‹©ä¸æˆªæ–­ï¼Œåˆ™è¯¥å‚æ•°ä» `Leftover` å¼¹å‡ºå¹¶å‹å…¥ `Pre`ï¼Œæ­¤æ—¶ä¸ç›´æ¥æ„å»ºä»»ä½•å‡½æ•°ï¼ˆå‚æ•°åˆ—è¡¨è¿˜åœ¨ç»§ç»­å»¶ä¼¸ï¼‰ï¼Œè€Œæ˜¯è¿”å›è¿›ä¸€æ­¥åŠ¨æ€æŸ¯é‡ŒåŒ–çš„ç»“æœï¼Œ`CurriedFunc<Ls, Ret, [...Pre, L0]>`<sup>(5)</sup>ã€‚

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ã€‚å¾—åˆ°çš„ä¸åŒçš„æŸ¯é‡ŒåŒ–ç»“æœï¼Œåº”è¯¥ç”¨ä»€ä¹ˆé€»è¾‘ç¬¦å·ç›¸è¿<sup>(6)</sup>ï¼Ÿæœ€å¼€å§‹ä¹ æƒ¯æ€§åœ°å†™äº†æå– `|`ï¼Œä½†åŠ¨æ€æŸ¯é‡ŒåŒ–å¾—åˆ°çš„ç»“æœå¹¶ä¸æ˜¯éšæœºé€‰æ‹©è¿™äº›å‡½æ•°ç±»å‹çš„å…¶ä¸­ä¹‹ä¸€ï¼Œè€Œæ˜¯æ¯ä¸€ä¸ªç±»å‹æ‰€ä»£è¡¨çš„è°ƒç”¨é“¾éƒ½æ˜¯åˆæ³•çš„ã€‚æ‰€ä»¥è¿™é‡Œåº”è¯¥å–**åˆå–** `&`ã€‚

è¿™ä¸ªä¸œè¥¿çš„å®ç°æœ‰ç‚¹å¤æ‚ï¼Œå› ä¸ºåœ¨ `Function.prototype.bind` é‡Œé¢ä½¿ç”¨äº†å‰©ä½™å‚æ•°åï¼Œåœ¨æ‰€æœ‰å‚æ•°éƒ½å¡«å……äº†å®é™…å€¼ä»¥åå¹¶ä¸ä¼šè°ƒç”¨åŸå‡½æ•°ï¼Œè€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ª `() => R` ç±»å‹çš„å‡½æ•°ã€‚æ‰€ä»¥ï¼Œé™¤äº†ä½¿ç”¨ `bind` æ–¹æ³•ï¼Œæ¯ä¸€æ­¥åŠ¨æ€æŸ¯é‡ŒåŒ–è¿”å›çš„ç»“æœè¿˜éœ€è¦è®°å½•å½“å‰å·²ä½¿ç”¨çš„å‚æ•°ä¸ªæ•°ï¼Œæ‰€ä»¥è¿”å›çš„ä¸å†æ˜¯å‡½æ•°ï¼ˆfunctionï¼‰ï¼Œè€Œæ˜¯ C++ å‡½å­ï¼ˆfunctorï¼‰æˆ–å‡½æ•°å¯¹è±¡ï¼ˆfunction objectï¼‰ä¹‹ç±»çš„ä¸œè¥¿ã€‚è‡³äºæ€ä¹ˆåœ¨ JavaScript é‡Œå®ç° functorï¼Œæˆ‘ä¸ä¼šğŸ™ƒã€‚
