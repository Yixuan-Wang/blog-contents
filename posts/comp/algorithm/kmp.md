---
title: KMP 算法
date: 2020-06-11T21:39:02+08:00
category: 信息
tags:
  - 算法
keywords:
  - 字符串
math: true
---

KMP 算法是利用重复片段进行优化的，无回溯的字符串匹配算法。

<!-- more -->

## 回溯

> TL;DR | 暴力算法中存在不必要的**向左回退**比较。

**暴力**的字符串匹配算法会遇到回溯的情况，如下所示：

```
模式串 abc

    ababc
  1|^
  2|a^
! 3|ab^
! 4| ^
```

用**模式串**abc 匹配**目标串**ababc，在第 3 步中，先将模式串第 0 位对齐目标串第 0 位，模式串的前两位匹配成功，第 2 位匹配失败(3)，因此将模式串的第零位移动到目标串第 1 位重新对齐(4)，因而比较的位置**回溯**了，但由于(2)用模式串第 1 位 b 匹配目标串第 1 位 b 成功，(4)用模式串第 0 位 a 重新匹配目标串第 1 位必定失败，因此这样的回溯是妨害效率的。主要原因是，在回溯的过程中，原有的匹配成功信息没有被利用即被丢弃。

设模式串长度为$m$，目标串长度为$n$，最坏情况是每次都在模式串的最后一位匹配失败，即匹配$m$次后失败，一直比较到模式串和目标串右对齐，模式串的第零位对齐在目标串第$n-m$位，一共比较$n-m+1$次。由于$n \ge m$，因而最坏时间复杂度是$O(mn)$。

## KMP 算法

> TL;DR | KMP 算法利用了模式串中**重复**的片段，通过**对齐**这些片段实现不向左后退。

暴力算法中，每次在模式串第$i$位和目标串第$j$位匹配失败以后，模式串左端总是向右移动 1 位。而\***\*KMP 算法\*\***的思路是，根据模式串的某种规律（将在下文分析），得出一个对应关系$next$，使得在模式串第$i$位和目标串第$j$位匹配失败以后，使得模式串的$next(i)$位和目标串$j$位对齐，即模式串左端向右移动$i-next(i)$位，**避免发生回溯**。分析以下操作的例子：

```
模式串 abcdabd

    0   45
    abcdaabcda
! 1|abcda^
  2|    a^
    *   *

    01  456
    abcdabcdabd
! 3|abcdab^
  4|    ab^
    **  **
```

先看$i\ne0$时的情况。

对于模式串$p$匹配失败的第$i$位**之前的**部分，即子串$p'_{i}=p_0 p_1 \dots p_{i-1}$，我们希望找到$p'_{i}$中**最长**的一对**完全相同**的**前缀和后缀**，并把它的长度记作$k_i$，即：

$$
p_0 p_1 \dots p_{k_i-1} = p_{i-k_i} p_{i-k_i+1} \dots p_{i-1}
$$

并通过移位使得**前缀左端**移到原来**后缀左端**对应的位置，可以得到：

$$
next(i) = k_i\tag{1}
$$

如果找不到符合上述要求的一对前缀和后缀时，将模式串的左端直接对齐到匹配失败的一位即可。此时$k_i=0$，公式$(1)$仍然成立。

如果$i=0$，也就是第 0 位已经匹配失败，则模式串的左端移到$i+1$，继续比较。令$k_0=-1$，公式$(1)$仍然成立，只是$p_{-1}$没有意义。课本上基于此点把这两个混在一起了，多循环了一次，个人觉得有点还是分开处理比较好理解。

在$j < n$时如果找到目标串中匹配模式串的子串，即满足$i=m-1$时匹配，则返回模式串左端位置$j-i$。如果$j=n$，说明目标串中不存在匹配模式串的字串，返回表示搜索无结果的值。

在搜索过程中，$j$不会减小（即不会发生回溯），递增的次数不会超过$n$。$j$递增的同时，一定伴随着$i$递增，$i$在匹配失败时也会减小，但最多减小到 0，减小的次数不会多于增加的次数，因此最终$i$递增的次数不会超过$2n$。所以，搜索部分的最坏时间复杂度是$O(n)$。

## 模式串的预处理

> TL;DR | 通过递推的方法可以快速推出$next(i)$表，还可以再进行递归优化避免在移动模式串前后比较内容相同的情况。

问题的关键转移到了计算**最长相同前后缀长度**$k_i$。这里利用递推会比较简单。

```
模式串 ababba

   0  1  2  3  4  5
   a  b  a  b  b  a
0|-1  0  0

 | *     ^
1|-1  0  0->1

 | *  *  ^  ^
2|-1  0  0  1->2

...
 | *  *  !
 |       ^  ^  !
3|-1  0  0  1  2->0
```

初始条件(0)是$k_0=-1, k_1=0$。

注意到：

$$
p_a p_{a+1} \dots p_{a+k-2} p_{a+k-1} = p_b p_{b+1} \dots p_{b+k-2} p_{b+k-1} \\
p_{a} p_{a+1} \dots p_{a+k-2} = p_b p_{b+1} \dots p_{b+k-2}
$$

可知$k_i > 0 \Leftrightarrow k_{i-1} = k_i - 1$。据(1)-(3)归纳，每次只需验证**上一次验证**中前缀末尾和后缀末尾的下一位是否相等，即：

$$
k_i =
\begin{cases}
   k_{i-1}+1 &p_{i-1} = p_{k_{i-1}}  \\
   0 &p_{i-1} \ne p_{k_{i-1}}
\end{cases}
\tag{2}
$$

这样就得到了$next$，但是还有优化的空间。

```
模式串 abab
   a  b  a  b
k -1  0  0  1

    abaabab
! 1|aba^
! 2|  a^
  3|   ^
```

在这个例子中，发现(1)匹配失败，(2)必定也匹配失败，两次比较的字符完全相同，多了一次无谓的比较，根本原因是$s_j \ne p_{i}=p_{k_i}$，使得移动模式串后，比较的字符没有变，还需要再次移动。因此，可以对$k_i$（当然也是$next(i)$）**递归地优化**：当$p_i = p_{k_i}$时，令$k_i = k_{k_i}$ ，或者写作“令$next(i) = next(next(i))$”，可能更方便理解。

对于上例，优化效果如下所示：

```
模式串 abab
    a  b  a  b
k  -1  0  0  1
k' -1  0 -1  0

    abaabab
! 1|aba^
  2|   ^
```

预处理过程中，递推部分的时间复杂度是$O(m)$；递归优化中，由于优化到第$i$项时第$next(i)$项已经优化过，因此不会再进行第二次递归，最坏时间复杂度是$O(m)$。因此，预处理过程的时间复杂度是$O(m)$。

## 结论

> TL;DR | KMP 算法时间复杂度是$O(m+n)$。

综上，KMP 算法的时间复杂度是$O(m+n)$，小于暴力算法的$O(mn)$。由于在实践中通常$m \ll n$，因此 KMP 算法的时间复杂度可以视为$O(n)$。但是，由于 KMP 算法的优化基于重复片段，因此使用的字符集比较大时（比如汉语的字符集），重复片段出现的概率低，它的效率提升也有限。实践中，从尾部开始向左匹配并计算“坏字符”的另一个字符串匹配算法，BM 算法，效率更高，可以达到$O(n)$，可以查看参考资料中的文章中的介绍。

## Python 实现

```python
NO_MATCH = -1

def kmp(p, s): # pattern 模式串, string 目标串
    m, n = len(p), len(s)
    i, j = 0, 0

    # 预处理
    nxt = [-1, 0] # next 预处理表
    for x in range(2, m):
        if p[x-1] == p[nxt[x-1]]: # 公式(2)
            nxt.append(nxt[x-1] + 1)
        else:
            nxt.append(0)
    for x in range(1, m):
        if p[x] == p[nxt[x]]: # 递归优化
            nxt[x] = nxt[nxt[x]]

    # 比较
    while i < m and j < n:
        if p[i] == s[j]: # 匹配成功
            i += 1; j += 1
        else: # 匹配失败
            if nxt[i] == -1: # 向后移动1位
                i = 0; j += 1
            else:
                i = nxt[i] # 将nxt[i]位置和j位置对齐
    if i == m:
        return j - i # 返回子串的左端
    return NO_MATCH
```

## 参考资料

- [July，从头到尾彻底理解 KMP，2014](https://blog.csdn.net/v_july_v/article/details/7041827)
- 裘宗燕，数据结构与算法：Python 语言描述，2018
